import org.gradle.api.tasks.bundling.Zip

apply plugin: 'maven-publish'
apply plugin: 'signing'

boolean isReleaseBuild() {
  return !version.toString().contains('SNAPSHOT')
}

String getRepositoryUsername() {
  return hasProperty('sonatypeUsername') ? sonatypeUsername : ''
}

String getRepositoryPassword() {
  return hasProperty('sonatypePassword') ? sonatypePassword : ''
}

boolean isSkipSigning() {
  def value = project.findProperty('skipSigning')
  return value != null && value.toString().toBoolean()
}

boolean hasNonEmptyProperty(String name) {
  def value = project.findProperty(name)
  return value != null && value.toString().trim()
}

boolean hasSigningCredentials() {
  return hasNonEmptyProperty('signing.gnupg.keyName') ||
    (hasNonEmptyProperty('signing.keyId') && hasNonEmptyProperty('signing.password') && hasNonEmptyProperty('signing.secretKeyRingFile')) ||
    (hasNonEmptyProperty('signingKey') && hasNonEmptyProperty('signingPassword'))
}

boolean isSigningEnabled() {
  if (isSkipSigning()) {
    return false
  }
  def enabled = project.findProperty('enableSigning')
  return enabled != null && enabled.toString().toBoolean() && hasSigningCredentials()
}

if (project.plugins.hasPlugin('com.android.library')) {
  android {
    publishing {
      singleVariant('release') {
        withSourcesJar()
        withJavadocJar()
      }
    }
  }
}

afterEvaluate { Project p ->
  publishing {
    publications {
      create('maven', MavenPublication) {
        from components.release
        artifactId = POM_SETTING_ARTIFACT_ID
        pom {
          name = POM_SETTING_NAME
          packaging = POM_SETTING_PACKAGING
          description = POM_SETTING_DESCRIPTION
          url = POM_SETTING_URL
          scm {
            url = POM_SETTING_SCM_URL
            connection = POM_SETTING_SCM_CONNECTION
            developerConnection = POM_SETTING_SCM_DEV_CONNECTION
          }
          licenses {
            license {
              name = POM_SETTING_LICENCE_NAME
              url = POM_SETTING_LICENCE_URL
              distribution = POM_SETTING_LICENCE_DIST
            }
          }
          developers {
            developer {
              id = POM_SETTING_DEVELOPER_ID
              name = POM_SETTING_DEVELOPER_NAME
            }
          }
        }
      }
    }
    repositories {
      if (project.hasProperty('centralBundle') && project.property('centralBundle').toString() == 'true') {
        maven {
          name = 'CentralBundle'
          url = layout.buildDirectory.dir('central-bundle')
        }
      } else {
        maven {
          def releasesRepoUrl = uri('https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/')
          def snapshotsRepoUrl = uri('https://s01.oss.sonatype.org/content/repositories/snapshots/')
          url = isReleaseBuild() ? releasesRepoUrl : snapshotsRepoUrl
          credentials {
            username = getRepositoryUsername()
            password = getRepositoryPassword()
          }
        }
      }
    }
  }

  signing {
    if (isSigningEnabled()) {
      if (project.findProperty('useGpgCmd')?.toString()?.toBoolean()) {
        useGpgCmd()
      }
      required { isReleaseBuild() }
      sign publishing.publications.maven
    } else {
      logger.lifecycle('Skipping PGP signing because key material is not configured or signing was not explicitly enabled (-PenableSigning=true)')
    }
  }

  tasks.register('packageReleaseZip', Zip) {
    group = 'distribution'
    description = 'Packages release AAR, POM, sources and javadoc into a zip'
    dependsOn 'assembleRelease', 'sourcesJar', 'javadocJar', 'generatePomFileForMavenPublication'
    from("${buildDir}/outputs/aar") { include '*-release.aar' }
    from("${buildDir}/publications/maven") { include 'pom-default.xml'; into('maven') }
    from("${buildDir}/libs") { include '*-sources.jar', '*-javadoc.jar' }
    def artifactId = project.findProperty('POM_SETTING_ARTIFACT_ID') ?: project.name
    def versionName = (project.version?.toString()) ?: (project.findProperty('VERSION_NAME') ?: 'unspecified')
    archiveBaseName.set(artifactId)
    archiveVersion.set(versionName)
    destinationDirectory.set(file("${buildDir}/releasePackage"))
  }

  tasks.register('generateCentralBundleChecksums') {
    group = 'publishing'
    description = 'Generates SHA-256 and SHA-512 checksums for the Central bundle'
    doLast {
      def bundleDir = layout.buildDirectory.dir('central-bundle').get().asFile
      if (!bundleDir.exists()) {
        logger.lifecycle("Central bundle directory not found: ${bundleDir}")
        return
      }
      bundleDir.eachFileRecurse { File f ->
        if (f.isFile()) {
          ['SHA-256': 'sha256', 'SHA-512': 'sha512'].each { alg, ext ->
            def digest = java.security.MessageDigest.getInstance(alg)
            f.withInputStream { InputStream input ->
              byte[] buffer = new byte[8192]
              int read
              while ((read = input.read(buffer)) != -1) {
                digest.update(buffer, 0, read)
              }
            }
            new File(f.parentFile, "${f.name}.${ext}").text = digest.digest().collect { String.format('%02x', it) }.join()
          }
        }
      }
      logger.lifecycle('Checksums generated')
    }
  }

  tasks.register('zipCentralBundle', Zip) {
    group = 'publishing'
    description = 'Zips the Central bundle directory for manual upload'
    dependsOn 'generateCentralBundleChecksums'
    def artifactId = project.findProperty('POM_SETTING_ARTIFACT_ID') ?: project.name
    def versionName = (project.version?.toString()) ?: (project.findProperty('VERSION_NAME') ?: 'unspecified')
    archiveFileName.set("central-bundle-${artifactId}-${versionName}.zip")
    from(layout.buildDirectory.dir('central-bundle'))
    destinationDirectory.set(file("${buildDir}/distributions"))
  }
}
